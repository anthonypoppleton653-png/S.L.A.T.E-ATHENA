# Spec 023: SLATE Avatar System

- **Status**: Specified
- **Created**: 2026-02-09
- **Author**: ClaudeCode (Opus 4.6)
- **Spec-Kit**: Yes

## Overview

Design and develop an avatar representation of SLATE — a visual AI entity that embodies the system's personality, state, and evolution. The avatar uses Microsoft TRELLIS.2 for 3D generation, D3.js for 2D representations, and connects to real system state for dynamic expression.

## Avatar Concept

### Design Philosophy

The SLATE avatar should embody the **Watchmaker aesthetic** — a living mechanism that reveals its inner workings:

| Trait | Expression |
|-------|-----------|
| **Precision** | Clean geometric forms, golden ratio proportions |
| **Mechanism** | Visible internal components (gears, circuits, flows) |
| **Evolution** | Avatar changes as system capabilities grow |
| **Transparency** | Internal state is visible through translucent surfaces |
| **Craft** | Beauty from functional perfection |

### Avatar Forms

#### 1. Core Form — "The Architect"

The primary SLATE avatar is a **watchmaker's orrery** — a mechanical model showing system components orbiting a central core:

```
                    ★ Dashboard (outer ring)
                  /
        ☆ Ollama --- ★ ChromaDB
       /              \
★ Core ---- ☆ Agent Router ---- ★ Runner
       \              /
        ☆ MCP --- ★ K8s
                  \
                    ★ Autonomous Loop (outer ring)
```

**Visual Details:**
- Central core: Hexagonal prism (SLATE logo shape) with warm rust (#B85A3C) glow
- Orbiting nodes: Service representations on concentric rings
- Connection lines: Animated flow lines showing data paths
- Blueprint substrate: Faint grid underneath all components
- Jewel indicators: Color-coded status gems on each node

#### 2. 2D Form — Dashboard & Documentation

The 2D avatar is rendered with D3.js force-directed layout:
- SVG-based for resolution independence
- Animated node connections
- Responsive to system state changes
- Embeddable in wiki, GitHub Pages, and README

#### 3. 3D Form — TRELLIS.2 Generated

A full 3D mesh generated by TRELLIS.2 from a designed 2D reference image:
- **Input**: High-quality 2D render of "The Architect" concept
- **Output**: Textured GLB mesh with PBR materials
- **Materials**: Metallic rust (#B85A3C), brushed steel, glass (translucent)
- **Viewer**: `<model-viewer>` web component for GitHub Pages/dashboard

### State-Reactive Behavior

The avatar reflects real system state:

| System State | Avatar Expression |
|-------------|-------------------|
| All healthy | Full brightness, smooth orbit animation |
| Service down | Affected node dims, connection line breaks |
| High GPU load | Core glows brighter, heat shimmer effect |
| Task executing | Gear rotation speed increases |
| Idle | Slow, calm orbital motion |
| Error state | Affected node pulses red |
| Building/CI | Construction scaffolding overlay |
| Training model | Neural network visualization in core |

### Evolution System

The avatar evolves as SLATE capabilities grow:

| Phase | Avatar Level | Visual Change |
|-------|-------------|---------------|
| Phase 1 Complete | Level 1 | Basic orrery with 5 nodes |
| 50% Phase 2 | Level 2 | 12 nodes, outer ring appears |
| 75% Phase 2 | Level 3 | Full orrery, glass dome enclosure |
| Phase 2 Complete | Level 4 | Golden ratio spiral overlay, premium materials |
| All Specs Complete | Level 5 | Watchmaker masterpiece, all animations active |

Current SLATE: **Level 3** (Phase 2 ~85% complete based on tech tree)

## TRELLIS.2 Integration

### Pipeline

```
1. Design 2D concept art (SVG/PNG reference images)
2. Process through TRELLIS.2 image-to-3D pipeline
3. Extract GLB mesh with PBR textures
4. Post-process: Optimize mesh, apply SLATE materials
5. Deploy: model-viewer in dashboard, GitHub Pages
6. Animate: JavaScript-driven state reactions
```

### K8s Service

```yaml
# trellis2-svc: GPU container for 3D generation
apiVersion: apps/v1
kind: Deployment
metadata:
  name: trellis2-generator
  namespace: slate
spec:
  replicas: 1
  template:
    spec:
      containers:
      - name: trellis2
        image: ghcr.io/synchronizedlivingarchitecture/trellis2:latest
        resources:
          limits:
            nvidia.com/gpu: 1
        ports:
        - containerPort: 8085
```

### Hardware Constraints

- RTX 5070 Ti (16GB) — requires `low_vram` mode
- Target resolution: 512^3 (fits in 16GB, ~3s generation)
- Fallback: Pre-generated assets if GPU insufficient

## Implementation

### Phase 1: 2D Avatar (D3.js)
1. Force-directed node graph with SLATE services
2. State-reactive animations (connect to dashboard API)
3. Embed in GitHub Pages and dashboard
4. SVG export for documentation

### Phase 2: 3D Avatar (TRELLIS.2)
1. Create 2D reference art from Phase 1 renders
2. Deploy TRELLIS.2 K8s service
3. Generate 3D mesh from reference
4. Integrate model-viewer component
5. Deploy to GitHub Pages

### Phase 3: Living Avatar
1. Connect to real-time system state API
2. WebSocket-driven animation updates
3. Evolution tracking tied to tech tree
4. Community showcase in GitHub Discussions

## Files

| File | Purpose |
|------|---------|
| `slate/slate_avatar.py` | Avatar state engine |
| `slate_web/avatar/` | 2D D3.js avatar component |
| `docs/pages/avatar.html` | GitHub Pages 3D viewer |
| `.slate_identity/avatar_state.json` | Current avatar evolution state |
| `k8s/trellis2-generator.yaml` | K8s deployment for TRELLIS.2 |

## Success Criteria

- 2D avatar renders in dashboard with state reactivity
- 3D avatar viewable on GitHub Pages with model-viewer
- Avatar evolution tracked in tech tree
- Avatar changes reflect real system state within 5 seconds
- All avatar assets stored in .slate_identity/
