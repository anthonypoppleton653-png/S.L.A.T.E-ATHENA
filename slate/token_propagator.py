#!/usr/bin/env python3
# Modified: 2026-02-09T12:39:00-05:00 | Author: Gemini (Antigravity)
# Change: Create token propagation pipeline â€” design-tokens.json â†’ all surfaces
# NOTE: All AIs modifying this file must add a dated comment.
"""
SLATE Token Propagator
======================

Reads the canonical `design-tokens.json` and propagates tokens to all output
formats used across the SLATE ecosystem. This ensures a single source of truth
for all visual surfaces.

Output targets:
  1. CSS Variables    â†’ dashboard/static/tokens.css
  2. CSS Variables    â†’ plugins/slate-copilot/media/tokens.css
  3. CSS Variables    â†’ .slate_identity/theme.css
  4. Python Constants â†’ slate/design_tokens_generated.py
  5. VSCode Theme     â†’ plugins/slate-copilot/themes/slate-dark.json
  6. GitHub Labels    â†’ .github/labels.yml
  7. CLI Theme        â†’ slate_core/cli_theme_generated.py

Usage:
    python slate/token_propagator.py                   # Propagate all
    python slate/token_propagator.py --validate         # Check sync
    python slate/token_propagator.py --format css       # Generate CSS only
    python slate/token_propagator.py --diff             # Show what would change
"""

import json
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, List, Optional

WORKSPACE_ROOT = Path(os.environ.get("SLATE_WORKSPACE", Path(__file__).parent.parent))
TOKENS_SOURCE = WORKSPACE_ROOT / "design-tokens.json"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Output Generators
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class OutputGenerator:
    """Base class for token output generators."""

    def __init__(self, output_path: str):
        self.output_path = WORKSPACE_ROOT / output_path

    def generate(self, tokens: Dict[str, Any]) -> str:
        """Generate the output content string."""
        raise NotImplementedError

    def write(self, tokens: Dict[str, Any]) -> bool:
        """Write generated content to file."""
        content = self.generate(tokens)
        self.output_path.parent.mkdir(parents=True, exist_ok=True)
        try:
            self.output_path.write_text(content, encoding="utf-8")
            return True
        except Exception as e:
            print(f"  âœ— Error writing {self.output_path}: {e}", file=sys.stderr)
            return False

    def is_in_sync(self, tokens: Dict[str, Any]) -> bool:
        """Check if the output file matches what would be generated."""
        if not self.output_path.exists():
            return False
        try:
            current = self.output_path.read_text(encoding="utf-8")
            expected = self.generate(tokens)
            return current.strip() == expected.strip()
        except Exception:
            return False


class CSSOutput(OutputGenerator):
    """Generate CSS custom properties from tokens."""

    def generate(self, tokens: Dict[str, Any]) -> str:
        ts = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
        lines = [
            f"/* SLATE Design Tokens â€” Auto-generated by token_propagator.py */",
            f"/* Source: design-tokens.json v{tokens.get('version', '?')} */",
            f"/* Generated: {ts} | Author: Gemini */",
            f"/* WARNING: Do not edit manually â€” regenerate with: python slate/token_propagator.py */",
            f"",
            f":root {{",
        ]

        token_data = tokens.get("tokens", {})

        # Colors
        colors = token_data.get("color", {})
        lines.append(f"  /* â”€â”€ Colors â”€â”€ */")
        self._flatten_css(colors, "slate-color", lines)

        # Typography
        typo = token_data.get("typography", {})
        lines.append(f"")
        lines.append(f"  /* â”€â”€ Typography â”€â”€ */")
        if "display" in typo:
            lines.append(f"  --slate-font-display: {typo['display'].get('family', 'system-ui')};")
        if "body" in typo:
            lines.append(f"  --slate-font-body: {typo['body'].get('family', 'serif')};")
        if "mono" in typo:
            lines.append(f"  --slate-font-mono: {typo['mono'].get('family', 'monospace')};")

        # Type scale
        scale = typo.get("scale", {})
        for name, props in scale.items():
            css_name = name.replace("_", "-")
            lines.append(f"  --slate-text-{css_name}-size: {props.get('size', '16px')};")
            lines.append(f"  --slate-text-{css_name}-weight: {props.get('weight', 400)};")
            lines.append(f"  --slate-text-{css_name}-line-height: {props.get('line-height', '1.5')};")

        # Spacing
        spacing = token_data.get("spacing", {})
        lines.append(f"")
        lines.append(f"  /* â”€â”€ Spacing â”€â”€ */")
        for key, val in spacing.items():
            lines.append(f"  --slate-space-{key}: {val};")

        # Radius
        radius = token_data.get("radius", {})
        lines.append(f"")
        lines.append(f"  /* â”€â”€ Radius â”€â”€ */")
        for key, val in radius.items():
            lines.append(f"  --slate-radius-{key}: {val};")

        # Elevation
        elevation = token_data.get("elevation", {})
        lines.append(f"")
        lines.append(f"  /* â”€â”€ Elevation â”€â”€ */")
        for key, val in elevation.items():
            lines.append(f"  --slate-elevation-{key}: {val};")

        # Motion
        motion = token_data.get("motion", {})
        lines.append(f"")
        lines.append(f"  /* â”€â”€ Motion â”€â”€ */")
        for category, values in motion.items():
            if isinstance(values, dict):
                for key, val in values.items():
                    lines.append(f"  --slate-{category}-{key}: {val};")

        lines.append(f"}}")
        return "\n".join(lines) + "\n"

    def _flatten_css(self, obj: Any, prefix: str, lines: List[str], depth: int = 0):
        """Recursively flatten nested token objects into CSS custom properties."""
        if isinstance(obj, dict):
            for key, value in obj.items():
                new_prefix = f"{prefix}-{key}"
                self._flatten_css(value, new_prefix, lines, depth + 1)
        elif isinstance(obj, (str, int, float)):
            lines.append(f"  --{prefix}: {obj};")


class PythonOutput(OutputGenerator):
    """Generate Python constants from tokens."""

    def generate(self, tokens: Dict[str, Any]) -> str:
        ts = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
        lines = [
            f'#!/usr/bin/env python3',
            f'# SLATE Design Tokens â€” Auto-generated by token_propagator.py',
            f'# Source: design-tokens.json v{tokens.get("version", "?")}',
            f'# Generated: {ts} | Author: Gemini',
            f'# WARNING: Do not edit manually â€” regenerate with: python slate/token_propagator.py',
            f'"""Auto-generated design token constants."""',
            f'',
            f'VERSION = "{tokens.get("version", "0.0.0")}"',
            f'LOCKED = {tokens.get("locked", True)}',
            f'',
        ]

        token_data = tokens.get("tokens", {})

        # Generate flat constants
        self._flatten_py(token_data, "TOKEN", lines)

        # Also generate as dict for programmatic access
        lines.append(f'')
        lines.append(f'TOKENS = {json.dumps(token_data, indent=2)}')

        return "\n".join(lines) + "\n"

    def _flatten_py(self, obj: Any, prefix: str, lines: List[str]):
        if isinstance(obj, dict):
            for key, value in obj.items():
                new_prefix = f"{prefix}_{key.upper().replace('-', '_')}"
                self._flatten_py(value, new_prefix, lines)
        elif isinstance(obj, str):
            lines.append(f'{prefix} = "{obj}"')
        elif isinstance(obj, (int, float)):
            lines.append(f'{prefix} = {obj}')


class VSCodeThemeOutput(OutputGenerator):
    """Generate VSCode theme JSON from tokens."""

    def generate(self, tokens: Dict[str, Any]) -> str:
        token_data = tokens.get("tokens", {})
        colors = token_data.get("color", {})
        primary = colors.get("primary", {})
        surface = colors.get("surface", {})
        status = colors.get("status", {})
        blueprint = colors.get("blueprint", {})

        theme = {
            "$schema": "vscode://schemas/color-theme",
            "name": "SLATE Dark",
            "type": "dark",
            "colors": {
                "editor.background": surface.get("base", {}).get("dark", "#1A1816"),
                "editor.foreground": surface.get("on", {}).get("dark", "#E8E2DE"),
                "sideBar.background": surface.get("variant", {}).get("dark", "#2A2624"),
                "activityBar.background": blueprint.get("bg", "#0D1B2A"),
                "activityBar.foreground": blueprint.get("node", "#E0FBFC"),
                "statusBar.background": primary.get("dark", "#8B4530"),
                "statusBar.foreground": primary.get("on", {}).get("dark", "#2A1508"),
                "titleBar.activeBackground": surface.get("base", {}).get("dark", "#1A1816"),
                "titleBar.activeForeground": surface.get("on", {}).get("dark", "#E8E2DE"),
                "terminal.foreground": surface.get("on", {}).get("dark", "#E8E2DE"),
                "terminal.background": surface.get("base", {}).get("dark", "#1A1816"),
                "badge.background": primary.get("base", "#B85A3C"),
                "badge.foreground": "#FFFFFF",
                "button.background": primary.get("base", "#B85A3C"),
                "button.foreground": "#FFFFFF",
                "focusBorder": primary.get("light", "#D4785A"),
                "errorForeground": status.get("error", "#F44336"),
                "list.activeSelectionBackground": f"{primary.get('base', '#B85A3C')}40",
                "list.hoverBackground": f"{primary.get('base', '#B85A3C')}20",
                "tab.activeBackground": surface.get("base", {}).get("dark", "#1A1816"),
                "tab.inactiveBackground": surface.get("variant", {}).get("dark", "#2A2624"),
                "panel.background": surface.get("variant", {}).get("dark", "#2A2624"),
                "panel.border": colors.get("outline", {}).get("variant", {}).get("dark", "#4D4845"),
            },
            "tokenColors": [
                {
                    "scope": ["comment"],
                    "settings": {"foreground": "#6B7280", "fontStyle": "italic"}
                },
                {
                    "scope": ["string"],
                    "settings": {"foreground": status.get("active", "#4CAF50")}
                },
                {
                    "scope": ["keyword", "storage.type"],
                    "settings": {"foreground": primary.get("light", "#D4785A")}
                },
                {
                    "scope": ["entity.name.function"],
                    "settings": {"foreground": blueprint.get("accent", "#98C1D9")}
                },
                {
                    "scope": ["entity.name.type", "entity.name.class"],
                    "settings": {"foreground": colors.get("watchmaker", {}).get("gold", "#DAA520")}
                },
                {
                    "scope": ["constant.numeric"],
                    "settings": {"foreground": colors.get("watchmaker", {}).get("brass", "#C9A959")}
                },
                {
                    "scope": ["variable.parameter"],
                    "settings": {"foreground": blueprint.get("node", "#E0FBFC")}
                },
            ],
        }

        return json.dumps(theme, indent=2) + "\n"


class GitHubLabelsOutput(OutputGenerator):
    """Generate GitHub labels.yml from token colors."""

    def generate(self, tokens: Dict[str, Any]) -> str:
        token_data = tokens.get("tokens", {})
        colors = token_data.get("color", {})
        primary = colors.get("primary", {})
        status = colors.get("status", {})
        step = colors.get("step", {})

        # Strip # from hex colors
        def strip_hash(c):
            return c.lstrip("#") if isinstance(c, str) else c

        labels = [
            {"name": "priority:critical", "color": strip_hash(status.get("error", "#F44336")),
             "description": "Critical priority"},
            {"name": "priority:high", "color": strip_hash(status.get("pending", "#FF9800")),
             "description": "High priority"},
            {"name": "priority:medium", "color": strip_hash(primary.get("base", "#B85A3C")),
             "description": "Medium priority"},
            {"name": "priority:low", "color": strip_hash(status.get("info", "#2196F3")),
             "description": "Low priority"},
            {"name": "status:active", "color": strip_hash(step.get("active", "#3B82F6")),
             "description": "Actively in progress"},
            {"name": "status:complete", "color": strip_hash(step.get("complete", "#22C55E")),
             "description": "Completed"},
            {"name": "status:blocked", "color": strip_hash(step.get("error", "#EF4444")),
             "description": "Blocked"},
            {"name": "type:spec", "color": strip_hash(primary.get("light", "#D4785A")),
             "description": "Specification document"},
            {"name": "type:feature", "color": strip_hash(status.get("active", "#4CAF50")),
             "description": "New feature"},
            {"name": "type:bug", "color": strip_hash(status.get("error", "#F44336")),
             "description": "Bug report"},
            {"name": "type:docs", "color": strip_hash(status.get("info", "#2196F3")),
             "description": "Documentation"},
            {"name": "agent:antigravity", "color": strip_hash(primary.get("base", "#B85A3C")),
             "description": "Modified by Antigravity"},
            {"name": "agent:copilot", "color": strip_hash(status.get("info", "#2196F3")),
             "description": "Modified by Copilot"},
            {"name": "agent:claude", "color": strip_hash(status.get("active", "#4CAF50")),
             "description": "Modified by Claude"},
        ]

        lines = [
            f"# SLATE GitHub Labels â€” Auto-generated by token_propagator.py",
            f"# Source: design-tokens.json v{tokens.get('version', '?')}",
            f"# Generated: {datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ')}",
            f"# WARNING: Do not edit manually",
            f"",
        ]
        for label in labels:
            lines.append(f"- name: \"{label['name']}\"")
            lines.append(f"  color: \"{label['color']}\"")
            lines.append(f"  description: \"{label['description']}\"")
            lines.append(f"")

        return "\n".join(lines) + "\n"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Token Propagator
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class TokenPropagator:
    """
    Reads design-tokens.json and propagates to all output formats.

    Run manually:  python slate/token_propagator.py
    Run auto:      Pre-commit hook, CI pipeline
    """

    OUTPUTS = [
        CSSOutput("dashboard/static/tokens.css"),
        CSSOutput("plugins/slate-copilot/media/tokens.css"),
        CSSOutput(".slate_identity/theme.css"),
        PythonOutput("slate/design_tokens_generated.py"),
        VSCodeThemeOutput("plugins/slate-copilot/themes/slate-dark.json"),
        GitHubLabelsOutput(".github/labels.yml"),
    ]

    def __init__(self, tokens_path: Path = TOKENS_SOURCE):
        self.tokens_path = tokens_path

    def load_tokens(self) -> Dict[str, Any]:
        """Load the source design tokens."""
        if not self.tokens_path.exists():
            print(f"  âœ— Token source not found: {self.tokens_path}", file=sys.stderr)
            return {}
        return json.loads(self.tokens_path.read_text(encoding="utf-8"))

    def propagate(self, formats: Optional[List[str]] = None) -> Dict[str, bool]:
        """
        Read source tokens, generate all output formats.

        Args:
            formats: Optional list of format names to generate (e.g., ["css", "python"]).
                     If None, generates all formats.

        Returns:
            Dict mapping output path to success boolean.
        """
        tokens = self.load_tokens()
        if not tokens:
            return {}

        results = {}
        for output in self.OUTPUTS:
            if formats:
                # Filter by format name
                fmt = type(output).__name__.lower().replace("output", "")
                if fmt not in [f.lower() for f in formats]:
                    continue

            success = output.write(tokens)
            rel_path = str(output.output_path.relative_to(WORKSPACE_ROOT))
            results[rel_path] = success
            icon = "âœ“" if success else "âœ—"
            print(f"  {icon} {rel_path}")

        return results

    def validate(self) -> Dict[str, bool]:
        """Ensure all outputs are in sync with source tokens."""
        tokens = self.load_tokens()
        if not tokens:
            return {}

        results = {}
        for output in self.OUTPUTS:
            in_sync = output.is_in_sync(tokens)
            rel_path = str(output.output_path.relative_to(WORKSPACE_ROOT))
            results[rel_path] = in_sync
            icon = "âœ“" if in_sync else "âœ—"
            status = "in sync" if in_sync else "OUT OF SYNC"
            print(f"  {icon} {rel_path} â€” {status}")

        return results

    def diff(self) -> Dict[str, str]:
        """Show what would change on propagation."""
        tokens = self.load_tokens()
        if not tokens:
            return {}

        diffs = {}
        for output in self.OUTPUTS:
            rel_path = str(output.output_path.relative_to(WORKSPACE_ROOT))
            expected = output.generate(tokens)

            if not output.output_path.exists():
                diffs[rel_path] = f"[NEW FILE] {len(expected)} bytes"
                print(f"  + {rel_path} [NEW]")
            else:
                current = output.output_path.read_text(encoding="utf-8")
                if current.strip() != expected.strip():
                    diffs[rel_path] = f"[MODIFIED]"
                    print(f"  ~ {rel_path} [MODIFIED]")
                else:
                    print(f"  = {rel_path} [no change]")

        return diffs


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CLI
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    """CLI: python slate/token_propagator.py [--validate|--diff|--format FMT]"""
    import argparse
    parser = argparse.ArgumentParser(description="SLATE Token Propagator")
    parser.add_argument("--validate", action="store_true", help="Check if all outputs are in sync")
    parser.add_argument("--diff", action="store_true", help="Show what would change")
    parser.add_argument("--format", type=str, help="Generate only specific format (css, python, vscode, github)")

    args = parser.parse_args()
    propagator = TokenPropagator()

    print(f"\n  ğŸ¨ SLATE Token Propagator")
    print(f"  Source: {TOKENS_SOURCE}")
    print(f"  {'â”€' * 50}")

    if args.validate:
        results = propagator.validate()
        all_sync = all(results.values())
        print(f"\n  {'âœ… All outputs in sync' if all_sync else 'âŒ Some outputs out of sync'}")
    elif args.diff:
        diffs = propagator.diff()
        if not diffs:
            print(f"\n  âœ… No changes needed")
    else:
        formats = [args.format] if args.format else None
        results = propagator.propagate(formats)
        success = sum(1 for v in results.values() if v)
        total = len(results)
        print(f"\n  âœ… Generated {success}/{total} outputs")

    print()


if __name__ == "__main__":
    main()
